# Key Service Helm Chart

This Helm chart deploys the Key Service - a secure key management service for signing verifiable credentials using multiple signature formats (JWT, Data Integrity, SD-JWT).

## Overview

The Key Service provides:

- **Secure Key Management**: Generate and store cryptographic keys with encryption at rest
- **Multiple Signature Formats**: JWT, Data Integrity (Ed25519, ES256), SD-JWT
- **W3C Verifiable Credentials**: Full support for W3C VC Data Model 2.0
- **Request Encryption**: Optional AES-256-GCM request encryption
- **Health Checks**: Kubernetes-ready liveness and readiness probes
- **PostgreSQL Storage**: Encrypted key storage in PostgreSQL
- **Simple ClusterIP Service**: Internal cluster access only

## Prerequisites

- Kubernetes cluster (1.24+)
- Helm 3.x installed
- kubectl configured to access your cluster

## Quick Start

### Default Installation

Install with default settings:

```bash
# Add Bitnami repository
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update

# Update dependencies
cd helm
helm dependency update

# Install
helm install key-service ./ \
  --create-namespace \
  --namespace key-service \
  --set keyService.tag=v1.7.0
```

## Configuration

### Values.yaml Configuration

Key configuration options in `values.yaml`:

#### Key Service Configuration

```yaml
keyService:
  image: ghcr.io/european-epc-competence-center/key-service
  tag: latest
  port: 3000
  nodeEnv: production
  replicas: 1
  
  # Request encryption
  requestEncryption:
    enabled: false
    sharedSecret: ""  # Auto-generated if not provided
  
  # Resource limits
  resources:
    requests:
      memory: "256Mi"
      cpu: 125m
    limits:
      memory: "512Mi"
      cpu: 250m
```

#### PostgreSQL Configuration

```yaml
postgresql:
  enabled: true
  auth:
    database: key_service
    username: postgres
    postgresPassword: ""  # Auto-generated
  
  primary:
    persistence:
      enabled: true
      size: 10Gi
    
    resources:
      requests:
        memory: "256Mi"
        cpu: 125m
      limits:
        memory: "512Mi"
        cpu: 250m
```


## Deployment Scenarios

### Development Deployment

```bash
helm install key-service ./ \
  --namespace dev \
  --create-namespace \
  --set keyService.tag=latest \
  --set keyService.nodeEnv=development \
  --set postgresql.primary.persistence.size=5Gi
```

### Production Deployment

**⚠️ IMPORTANT**: The example below shows creating a Kubernetes secret for the signing key. This is **ONLY for development/testing**. In production, you **MUST** use HashiCorp Vault or equivalent secret management system. See the "Production Secret Management with Vault" section below.

```bash
# Create production namespace
kubectl create namespace production

# Create signing key secret (DEV/TEST ONLY - use Vault for production!)
kubectl create secret generic key-service-signing-key \
  --from-file=key=./production-signing-key \
  --namespace production
kubectl annotate secret key-service-signing-key \
  helm.sh/resource-policy=keep \
  --namespace production

# Install with production settings
helm install key-service ./ \
  --namespace production \
  --set keyService.tag=v1.7.0 \
  --set keyService.signingKey.existingSecret=true \
  --set keyService.requestEncryption.enabled=true \
  --set keyService.requestEncryption.sharedSecret="your-secure-secret" \
  --set keyService.replicas=2
```

### Using External PostgreSQL

```bash
# Create secret with external DB password
kubectl create secret generic external-postgresql \
  --from-literal=postgres-password='your-db-password' \
  --namespace key-service

# Install with external DB
helm install key-service ./ \
  --namespace key-service \
  --create-namespace \
  --set postgresql.enabled=false \
  --set postgresql.host=external-postgres.example.com \
  --set postgresql.auth.existingSecret=external-postgresql \
  --set postgresql.auth.database=key_service \
  --set postgresql.auth.username=postgres
```

## Secrets Management

The chart automatically generates the following secrets on first deployment:

1. **key-service-signing-key**: Cryptographic signing key for the service
   - Auto-generated as a random 64-character string
   - For production, create this manually before deployment
   - Retained across upgrades (`helm.sh/resource-policy: keep`)

2. **key-service-secret**: Service configuration secrets
   - `pbkdf2-iterations`: Random value between 100,000-300,000
   - `request-encryption-shared-secret`: (if request encryption enabled)
   - Immutable after creation
   - Retained across upgrades

3. **postgresql**: Database password
   - Auto-generated by PostgreSQL chart
   - Retained across upgrades

### ⚠️ Production Secret Management with Vault

**IMPORTANT**: The auto-generated signing key and mounting it via Kubernetes secrets is **only a workaround** for development and testing environments where HashiCorp Vault or similar secret management solutions are not available.

**For production deployments**, the signing key **MUST** be stored in and mounted from HashiCorp Vault (or equivalent secret management system), not as a Kubernetes secret. This ensures:

- **Centralized secret management** with proper access control
- **Audit logging** of secret access
- **Secret rotation** capabilities
- **Encryption at rest** with hardware security modules (HSM)
- **Dynamic secret generation** and revocation
- **Compliance** with security standards

#### Production Vault Integration

For production deployments with Vault:

1. Store the signing key in Vault
2. Use Vault Agent Injector or CSI driver to mount secrets
3. Configure the pod to read from the Vault-mounted path

Hashicorp example with Vault Agent Injector annotations:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: key-service
spec:
  template:
    metadata:
      annotations:
        vault.hashicorp.com/agent-inject: "true"
        vault.hashicorp.com/role: "key-service"
        vault.hashicorp.com/agent-inject-secret-signing-key: "secret/data/key-service/signing-key"
        vault.hashicorp.com/agent-inject-file-signing-key: "signing-key"
        vault.hashicorp.com/secret-volume-path: "/run/secrets"
    spec:
      # ... rest of deployment spec
```

### Creating Development/Test Signing Key

**For development/test environments only** (not for production):

```bash
# Generate a secure signing key
openssl rand -base64 64 > development-signing-key

# Create secret before deployment
kubectl create secret generic key-service-signing-key \
  --from-file=key=development-signing-key \
  --namespace your-namespace

# Mark secret to be kept across Helm operations
kubectl annotate secret key-service-signing-key \
  helm.sh/resource-policy=keep \
  --namespace your-namespace

# Deploy with existing secret
helm install key-service ./ \
  --namespace your-namespace \
  --set keyService.signingKey.existingSecret=true
```

## API Endpoints

Once deployed, the Key Service exposes the following endpoints:

### Signing Endpoints

- `POST /sign/vc/:type` - Sign verifiable credentials
  - Types: `jwt`, `data-integrity`, `sd-jwt`
- `POST /sign/vp/:type` - Sign verifiable presentations
  - Types: `jwt`, `data-integrity`, `sd-jwt`
- `POST /generate` - Generate new key pairs
  - Algorithms: `Ed25519`, `ES256`, `PS256`

### Health Endpoints

- `GET /health` - General health check with database connectivity
- `GET /health/liveness` - Kubernetes liveness probe
- `GET /health/readiness` - Kubernetes readiness probe

## Accessing the Service

### Within Cluster

The service is accessible at:
```
http://key-service-key-service.{namespace}.svc.cluster.local:3000
```

### Port Forwarding (for external access)

```bash
kubectl port-forward svc/key-service-key-service 3000:3000 -n key-service
```

Then access at: `http://localhost:3000`

## Monitoring

### Check Deployment Status

```bash
# Check pods
kubectl get pods -n key-service

# Check services
kubectl get svc -n key-service
```

### View Logs

```bash
# Key Service logs
kubectl logs -f deployment/key-service-key-service -n key-service

# PostgreSQL logs
kubectl logs -f statefulset/key-service-postgresql -n key-service
```

### Health Checks

```bash
# Via port-forward
kubectl port-forward svc/key-service-key-service 3000:3000 -n key-service
curl http://localhost:3000/health

# Via pod exec
kubectl exec -it deployment/key-service-key-service -n key-service -- \
  curl http://localhost:3000/health
```

## Upgrading

### Upgrade to New Version

```bash
# Update image tag
helm upgrade key-service ./ \
  --namespace key-service \
  --set keyService.tag=v1.8.0 \
  --reuse-values
```

### Update Configuration

```bash
# Enable request encryption
helm upgrade key-service ./ \
  --namespace key-service \
  --set keyService.requestEncryption.enabled=true \
  --set keyService.requestEncryption.sharedSecret="new-secret" \
  --reuse-values
```

### Upgrade PostgreSQL

```bash
# Update dependencies first
helm dependency update

# Upgrade (be careful with database upgrades)
helm upgrade key-service ./ \
  --namespace key-service \
  --reuse-values
```

## Backup and Restore

### Backup PostgreSQL Database

```bash
# Get database password
DB_PASSWORD=$(kubectl get secret key-service-postgresql \
  -n key-service \
  -o jsonpath='{.data.postgres-password}' | base64 -d)

# Port forward
kubectl port-forward svc/key-service-postgresql 5432:5432 -n key-service &

# Backup
PGPASSWORD=$DB_PASSWORD pg_dump \
  -h localhost \
  -U postgres \
  -d key_service \
  > key-service-backup-$(date +%Y%m%d).sql
```

### Restore PostgreSQL Database

```bash
# Port forward
kubectl port-forward svc/key-service-postgresql 5432:5432 -n key-service &

# Restore
PGPASSWORD=$DB_PASSWORD psql \
  -h localhost \
  -U postgres \
  -d key_service \
  < key-service-backup-20240101.sql
```

## Troubleshooting

### Pod Not Starting

```bash
# Check pod status
kubectl describe pod -l app.kubernetes.io/name=key-service -n key-service

# Check events
kubectl get events -n key-service --sort-by='.lastTimestamp'
```

### Database Connection Issues

```bash
# Check if PostgreSQL is running
kubectl get pods -l app.kubernetes.io/name=postgresql -n key-service

# Check PostgreSQL logs
kubectl logs -f statefulset/key-service-postgresql -n key-service

# Check database connectivity from key-service pod
kubectl exec -it deployment/key-service-key-service -n key-service -- \
  nc -zv key-service-postgresql 5432
```

### Signing Key Issues

```bash
# Check if signing key secret exists
kubectl get secret key-service-signing-key -n key-service

# Verify secret content (base64 encoded)
kubectl get secret key-service-signing-key -n key-service -o yaml

# Check if key is mounted in pod
kubectl exec -it deployment/key-service-key-service -n key-service -- \
  ls -la /run/secrets/signing-key
```

### Request Encryption Issues

```bash
# Check if request encryption is enabled
kubectl get deployment key-service-key-service -n key-service -o yaml | \
  grep REQUEST_ENCRYPTION_ENABLED

# Check if shared secret exists
kubectl get secret key-service-secret -n key-service -o yaml
```

### Health Check Failures

```bash
# Check health endpoint directly
kubectl exec -it deployment/key-service-key-service -n key-service -- \
  curl -v http://localhost:3000/health

# Check readiness probe
kubectl exec -it deployment/key-service-key-service -n key-service -- \
  curl -v http://localhost:3000/health/readiness

# Check liveness probe
kubectl exec -it deployment/key-service-key-service -n key-service -- \
  curl -v http://localhost:3000/health/liveness
```

## Removal

```bash
# Uninstall release
helm uninstall key-service --namespace key-service

# Delete PVCs (optional, deletes all data)
kubectl delete pvc -n key-service -l app.kubernetes.io/instance=key-service

# Delete namespace (optional)
kubectl delete namespace key-service
```

## Security Considerations

### ⚠️ Critical: Vault Required for Production

**The Kubernetes secret-based signing key in this Helm chart is a workaround for development/testing environments only.**

In production environments, **you MUST integrate with HashiCorp Vault** or equivalent secret management systems. Storing the signing key as a Kubernetes secret does not meet production security requirements.

See the "Production Secret Management with Vault" section above for integration details.

### Production Checklist

- ✅ Use a specific image tag (not `latest`)
- ✅ **Mount signing key from Vault** (not Kubernetes secrets)
- ✅ Use HashiCorp/Azure Vault or equivalent secret management system
- ✅ Enable request encryption for sensitive environments
- ✅ Use strong, randomly generated secrets
- ✅ Configure network policies to restrict access
- ✅ Enable pod security policies/standards
- ✅ Regular backups of PostgreSQL database
- ✅ Use separate namespaces for different environments
- ✅ Configure resource limits appropriately
- ✅ Expose service only within cluster (ClusterIP)
- ✅ Enable audit logging for secret access

### Network Security

```yaml
# Example NetworkPolicy to restrict access
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: key-service-network-policy
  namespace: key-service
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/name: key-service
  policyTypes:
    - Ingress
  ingress:
    # Allow from same namespace only
    - from:
      - podSelector: {}
```

## Additional Resources

- [Key Service Documentation](https://github.com/european-epc-competence-center/key-service)
- [Request Encryption Guide](../docs/REQUEST_ENCRYPTION_USAGE.md)
- [Security Concept](../docs/security_and_key_management_concept.md)
- [API Documentation](../README.md)

## Support

For issues, questions, or contributions:
- GitHub Issues: https://github.com/european-epc-competence-center/key-service/issues
- Email: christian.fries@eecc.de

## License

AGPL-3.0 - See LICENSE file for details

